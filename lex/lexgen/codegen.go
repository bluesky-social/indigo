package lexgen

import (
	"fmt"
	"io"
	"log/slog"
	"sort"
	"strings"

	"github.com/bluesky-social/indigo/atproto/lexicon"
	"github.com/bluesky-social/indigo/atproto/syntax"
)

type GenConfig struct {
	RegisterLexiconTypeID bool
	PackageMappings       map[string]string
	// one of: "type-decoder", "map-string-any", "json-raw-message"
	UnknownType string
	WarningText string
	LegacyMode  bool
}

func NewGenConfig() *GenConfig {
	return &GenConfig{
		UnknownType: "map-string-any",
		WarningText: "Code generated by indigo lexgen tool. DO NOT EDIT MANUALLY.",
	}
}

func LegacyConfig() *GenConfig {
	return &GenConfig{
		RegisterLexiconTypeID: true,
		UnknownType:           "type-decoder",
		WarningText:           "Code generated by cmd/lexgen (see Makefile's lexgen); DO NOT EDIT.",
		LegacyMode:            true,
	}
}

type FlatGenerator struct {
	Config *GenConfig
	Lex    *FlatLexicon
	Cat    lexicon.Catalog
	Out    io.Writer
}

func (gen *FlatGenerator) WriteLexicon() error {

	if gen.Config.WarningText != "" {
		fmt.Fprintf(gen.Out, "// %s\n\n", gen.Config.WarningText)
	}
	fmt.Fprintf(gen.Out, "// Lexicon schema: %s\n\n", gen.Lex.NSID)
	fmt.Fprintf(gen.Out, "package %s\n\n", gen.PkgName())
	fmt.Fprintln(gen.Out, "import (")
	for dep, _ := range gen.deps() {
		fmt.Fprintf(gen.Out, "    %s\n", dep)
	}
	fmt.Fprint(gen.Out, ")\n\n")

	for _, ft := range gen.Lex.Types {
		slog.Info("generating type", "nsid", gen.Lex.NSID, "def", ft.DefName, "path", ft.Path, "type", ft.Type)
		if err := gen.WriteType(&ft); err != nil {
			return err
		}
	}
	return nil
}

func (gen *FlatGenerator) PkgName() string {
	n := nsidPkgName(gen.Lex.NSID)
	if gen.Config.LegacyMode {
		switch n {
		case "appbsky":
			return "bsky"
		case "comatproto":
			return "atproto"
		case "toolsozone":
			return "ozone"
		case "chatbsky":
			return "chat"
		}
	}
	return n
}

func (gen *FlatGenerator) baseName() string {
	// TODO: memoize this value? this method gets called a lot
	return nsidBaseName(gen.Lex.NSID)
}

func (gen *FlatGenerator) FileName() string {
	return nsidFileName(gen.Lex.NSID) + ".go"
}

func (gen *FlatGenerator) deps() map[string]bool {
	d := map[string]bool{
		"\"context\"":       true,
		"\"fmt\"":           true,
		"\"io\"":            true,
		"\"bytes\"":         true,
		"\"encoding/json\"": true,
		"lexutil \"github.com/bluesky-social/indigo/lex/util\"": true,
		"cbg \"github.com/whyrusleeping/cbor-gen\"":             true,
	}

	for ext, _ := range gen.Lex.ExternalRefs {
		// TODO: replace this with
		if strings.HasPrefix(ext, "com.atproto.") {
			d["comatproto \"github.com/bluesky-social/indigo/api/atproto\""] = true
		} else if strings.HasPrefix(ext, "app.bsky.") {
			d["appbsky \"github.com/bluesky-social/indigo/api/bsky\""] = true
		} else if strings.HasPrefix(ext, "tools.ozone.") {
			d["toolsozone \"github.com/bluesky-social/indigo/api/ozone\""] = true
		} else if strings.HasPrefix(ext, "chat.bsky.") {
			d["chatbsky \"github.com/bluesky-social/indigo/api/chat\""] = true
		} else {
			// TODO: configurable mappings; and return error if none found
			slog.Error("unhandled external reference", "ref", ext)
		}
	}
	return d
}

func (gen *FlatGenerator) WriteType(ft *FlatType) error {

	switch v := ft.Schema.Inner.(type) {
	case lexicon.SchemaRecord:
		if gen.Config.RegisterLexiconTypeID {
			fmt.Fprintf(gen.Out, "func init() {\n")
			fmt.Fprintf(gen.Out, "    lexutil.RegisterType(\"%s\", &%s{})", gen.Lex.NSID, gen.baseName())
			fmt.Fprintf(gen.Out, "}\n\n")
		}
		// HACK: insert record-level description in to object if nil
		if v.Description != nil && v.Record.Description == nil {
			v.Record.Description = v.Description
		}
		if err := gen.writeStruct(ft, &v.Record); err != nil {
			return err
		}
	case lexicon.SchemaQuery:
		return gen.writeEndpoint(ft, defDescription(ft.Schema), v.Parameters, v.Output, nil, false)
	case lexicon.SchemaProcedure:
		return gen.writeEndpoint(ft, defDescription(ft.Schema), v.Parameters, v.Output, v.Input, true)
	case lexicon.SchemaSubscription:
		// pass; we only generate message types, not overall subscription
	case lexicon.SchemaPermissionSet, lexicon.SchemaPermission:
		// pass for Go codegen
	case lexicon.SchemaToken:
		// TODO: pass for now; could be a var/const?
	case lexicon.SchemaString, lexicon.SchemaInteger, lexicon.SchemaBoolean, lexicon.SchemaUnknown:
		// skip
	case lexicon.SchemaObject:
		if gen.Config.RegisterLexiconTypeID && ft.DefName == "main" && len(ft.Path) == 0 {
			fmt.Fprintf(gen.Out, "func init() {\n")
			fmt.Fprintf(gen.Out, "    lexutil.RegisterType(\"%s#main\", &%s{})", gen.Lex.NSID, gen.baseName())
			fmt.Fprintf(gen.Out, "}\n\n")
		}
		if err := gen.writeStruct(ft, &v); err != nil {
			return err
		}
	case lexicon.SchemaUnion:
		return gen.writeUnion(ft, &v)
	case lexicon.SchemaRef:
		// skip for now. could be an alias type?
	default:
		return fmt.Errorf("unhandled schema type for codegen: %T", ft.Schema.Inner)
	}

	return nil
}

func isRequired(required []string, fname string) bool {
	for _, k := range required {
		if k == fname {
			return true
		}
	}
	return false
}

func (gen *FlatGenerator) fieldType(fname string, def *lexicon.SchemaDef, optional bool) (string, error) {
	// NOTE: SchemaObject and SchemaUnion should be handled outside this function; as well as arrays of those types also count
	// TODO: another pass to check for type completeness
	switch v := def.Inner.(type) {
	case lexicon.SchemaNull:
		// NOTE: using "any" as a generic 'nil' type
		return "any", nil
	case lexicon.SchemaBoolean:
		if optional {
			return "*bool", nil
		} else {
			return "bool", nil
		}
	case lexicon.SchemaInteger:
		if optional {
			return "*int64", nil
		} else {
			return "int64", nil
		}
	case lexicon.SchemaString:
		if optional {
			return "*string", nil
		} else {
			return "string", nil
		}
	case lexicon.SchemaBytes:
		// NOTE: not using a pointer for optional
		return "lexutil.LexBytes", nil
	case lexicon.SchemaCIDLink:
		if optional {
			return "*lexutil.LexLink", nil
		} else {
			return "lexutil.LexLink", nil
		}
	case lexicon.SchemaBlob:
		if optional || gen.Config.LegacyMode {
			return "*lexutil.LexBlob", nil
		} else {
			return "lexutil.LexBlob", nil
		}
	case lexicon.SchemaArray:
		t, err := gen.fieldType(fname, &v.Items, false)
		if err != nil {
			return "", err
		}
		// NOTE: not using a pointer for optional
		return "[]" + t, nil
	case lexicon.SchemaUnknown:
		switch gen.Config.UnknownType {
		case "type-decoder":
			if gen.Config.LegacyMode && (fname == "didDoc" || fname == "plcOp" || fname == "meta" || fname == "debug") {
				if optional {
					return "*interface{}", nil
				} else {
					return "interface{}", nil
				}
			}
			return "*lexutil.LexiconTypeDecoder", nil
		case "json-raw-message":
			if optional {
				return "*json.RawMessage", nil
			} else {
				return "json.RawMessage", nil
			}
		case "map-string-any":
			return "map[string]any", nil
		default:
			return "map[string]any", nil
		}
	case lexicon.SchemaRef:
		ptr := ""
		if optional {
			ptr = "*"
		}

		// check for local references to concrete types first
		if strings.HasPrefix(v.Ref, "#") {
			dt, ok := gen.Lex.Defs[v.Ref[1:]]
			if !ok {
				return "", fmt.Errorf("broken self-reference: %s", v.Ref)
			}
			switch dt.Type {
			case "string":
				if gen.Config.LegacyMode {
					ptr = "*"
				}
				return ptr + "string", nil
			case "integer":
				return ptr + "int64", nil
			case "boolean":
				return ptr + "bool", nil
			// TODO: "unknown", "ref", "token", etc
			case "array":
				// TODO: more completeness here (eg, non-object types)
				structPtr := ""
				if gen.Config.LegacyMode {
					structPtr = "*"
				}
				return fmt.Sprintf("[]%s%s_%s_Elem", structPtr, gen.baseName(), strings.Title(v.Ref[1:])), nil
			default: // presumed "object", "union"
				if gen.Config.LegacyMode {
					ptr = "*"
				}
				if v.Ref == "#main" {
					return ptr + gen.baseName(), nil
				}
				return fmt.Sprintf("%s%s_%s", ptr, gen.baseName(), strings.Title(v.Ref[1:])), nil
			}
		}

		// external reference
		t, err := gen.externalRefType(v.Ref)
		if err != nil {
			return "", err
		}
		if gen.Config.LegacyMode {
			ptr = "*"
		}
		return ptr + t, nil
	default:
		return "", fmt.Errorf("unhandled schema type in struct field: %T", def.Inner)
	}
}

func (gen *FlatGenerator) externalRefType(ref string) (string, error) {
	s, err := gen.Cat.Resolve(ref)
	if err != nil {
		return "", fmt.Errorf("could not resolve lexicon reference (%s): %w", ref, err)
	}

	switch s.Def.(type) {
	case lexicon.SchemaString:
		return "string", nil
		// TODO: other concrete types and special-cases types, like arrays
	}

	parts := strings.SplitN(ref, "#", 3)
	if len(parts) > 2 {
		return "", fmt.Errorf("failed to parse external ref: %s", ref)
	}
	nsid, err := syntax.ParseNSID(parts[0])
	if err != nil {
		return "", fmt.Errorf("failed to parse external ref NSID (%s): %w", ref, err)
	}

	// check if this is actually in the same package (which might not mean the same NSID authority)
	if nsidPkgName(nsid) == nsidPkgName(gen.Lex.NSID) {
		if len(parts) == 1 || parts[1] == "main" {
			return nsidBaseName(nsid), nil
		} else {
			return fmt.Sprintf("%s_%s", nsidBaseName(nsid), strings.Title(parts[1])), nil
		}
	}

	if len(parts) == 1 || parts[1] == "main" {
		return fmt.Sprintf("%s.%s", nsidPkgName(nsid), nsidBaseName(nsid)), nil
	} else {
		return fmt.Sprintf("%s.%s_%s", nsidPkgName(nsid), nsidBaseName(nsid), strings.Title(parts[1])), nil
	}
}

func (gen *FlatGenerator) writeStruct(ft *FlatType, obj *lexicon.SchemaObject) error {

	name := gen.baseName()
	if ft.DefName != "main" {
		name += "_" + strings.Title(ft.DefName)
	}
	for _, sub := range ft.Path {
		name += "_" + strings.Title(sub)
	}

	if ft.DefName != "main" && len(ft.Path) == 0 {
		fmt.Fprintf(gen.Out, "// %s is a \"%s\" in the %s schema.\n", name, ft.DefName, gen.Lex.NSID)
		if obj.Description != nil {
			fmt.Fprintln(gen.Out, "//")
		}
	}
	if gen.Lex.Defs[ft.DefName].Type == "procedure" && len(ft.Path) == 1 && ft.Path[0] == "input" {
		// TODO: "request body"
		fmt.Fprintf(gen.Out, "// %s is the input argument to a %s call.\n", name, gen.Lex.NSID)
	}
	if (gen.Lex.Defs[ft.DefName].Type == "query" || gen.Lex.Defs[ft.DefName].Type == "procedure") && len(ft.Path) == 1 && ft.Path[0] == "output" {
		// TODO: "response body"
		fmt.Fprintf(gen.Out, "// %s is the output of a %s call.\n", name, gen.Lex.NSID)
	}
	skipDesc := false
	if gen.Config.LegacyMode && ft.Type == "record" {
		skipDesc = true
	}
	if obj.Description != nil && !skipDesc {
		for _, l := range strings.Split(*obj.Description, "\n") {
			fmt.Fprintf(gen.Out, "// %s\n", l)
		}
	}
	fmt.Fprintf(gen.Out, "type %s struct {\n", name)

	// iterate field in sorted order
	fieldNames := []string{}
	for fname := range obj.Properties {
		fieldNames = append(fieldNames, fname)
	}
	sort.Strings(fieldNames)

	// if this is a def-level struct, write out type decoder
	skipType := false
	if gen.Config.LegacyMode {
		// TODO: skip $type for all defs in subscription. this isn't robust!
		switch gen.Lex.MainType() {
		case "subscription":
			skipType = true
		}
	}
	if len(ft.Path) == 0 && !skipType {
		// TODO: can skip in some more situations?
		fullName := gen.Lex.NSID.String()
		if ft.DefName != "main" {
			fullName += "#" + ft.DefName
		}
		omitempty := ""
		if gen.Config.LegacyMode && gen.Lex.NSID.String() == "com.atproto.repo.strongRef" {
			omitempty = ",omitempty"
		}
		fmt.Fprintf(gen.Out, "    LexiconTypeID string `json:\"$type%s\" cborgen:\"$type,const=%s%s\"`\n", omitempty, fullName, omitempty)
	}

	for _, fname := range fieldNames {
		field := obj.Properties[fname]
		optional := false
		omitempty := ""
		if obj.IsNullable(fname) || !isRequired(obj.Required, fname) {
			optional = true
			omitempty = ",omitempty"
		}

		var t string
		var err error

		switch v := field.Inner.(type) {
		case lexicon.SchemaObject, lexicon.SchemaUnion:
			t = name + "_" + strings.Title(fname)
			if optional || gen.Config.LegacyMode {
				t = "*" + t
			}
		case lexicon.SchemaArray:
			switch v.Items.Inner.(type) {
			case lexicon.SchemaObject, lexicon.SchemaUnion:
				elemPtr := ""
				if gen.Config.LegacyMode {
					elemPtr = "*"
				}
				// NOTE: not using ptr for optional
				t = fmt.Sprintf("[]%s%s_%s_Elem", elemPtr, name, strings.Title(fname))
			default:
				t, err = gen.fieldType(fname, &field, optional)
				if err != nil {
					return err
				}
			}
		default:
			t, err = gen.fieldType(fname, &field, optional)
			if err != nil {
				return err
			}
		}

		cborExtra := ""
		// HACK: copied from legacy code for now
		if gen.Lex.NSID.String() == "com.atproto.label.defs" && name == "LabelDefs_SelfLabels" && fname == "values" {
			cborExtra = ",preservenil"
		}

		desc := defDescription(&field)
		if desc != "" {
			fmt.Fprintf(gen.Out, "    // %s: %s\n", fname, desc)
		}
		fmt.Fprintf(gen.Out, "    %s %s", strings.ReplaceAll(strings.Title(fname), "-", ""), t)
		fmt.Fprintf(gen.Out, " `json:\"%s%s\" cborgen:\"%s%s%s\"`\n", fname, omitempty, fname, omitempty, cborExtra)
	}
	fmt.Fprintf(gen.Out, "}\n\n")

	return nil
}

type unionRef struct {
	FieldName string
	TypeName  string
	LexName   string
}

func (gen *FlatGenerator) writeUnion(ft *FlatType, union *lexicon.SchemaUnion) error {

	name := gen.baseName()
	if ft.DefName != "main" {
		name += "_" + strings.Title(ft.DefName)
	}
	for _, sub := range ft.Path {
		name += "_" + strings.Title(sub)
	}

	unionRefs := map[string]unionRef{}
	refNames := []string{}
	for _, ref := range union.Refs {
		r := unionRef{
			LexName: ref,
		}

		if strings.HasPrefix(ref, "#") {
			r.LexName = gen.Lex.NSID.String() + ref
			n := gen.baseName()
			if ref != "#main" {
				n += "_" + strings.Title(ref[1:])
			}
			r.FieldName = n
			r.TypeName = n
		} else {
			n, err := gen.externalRefType(ref)
			if err != nil {
				return err
			}
			r.FieldName = n
			r.TypeName = n
			if strings.Contains(n, ".") {
				parts := strings.SplitN(n, ".", 2)
				r.FieldName = parts[1]
			}
		}
		refNames = append(refNames, r.FieldName)
		unionRefs[r.FieldName] = r
	}
	if !gen.Config.LegacyMode {
		sort.Strings(refNames)
	}

	// first print out the union struct type
	if union.Description != nil {
		for _, l := range strings.Split(*union.Description, "\n") {
			fmt.Fprintf(gen.Out, "// %s\n", l)
		}
	}
	fmt.Fprintf(gen.Out, "type %s struct {\n", name)
	for _, rname := range refNames {
		ref := unionRefs[rname]
		fmt.Fprintf(gen.Out, "    %s *%s\n", ref.FieldName, ref.TypeName)
	}
	fmt.Fprintf(gen.Out, "}\n\n")

	// ... then MarshalJSON
	fmt.Fprintf(gen.Out, "func (t *%s) MarshalJSON() ([]byte, error) {\n", name)
	for _, rname := range refNames {
		ref := unionRefs[rname]
		fmt.Fprintf(gen.Out, "    if t.%s != nil {\n", ref.FieldName)
		fmt.Fprintf(gen.Out, "        t.%s.LexiconTypeID = \"%s\"\n", ref.FieldName, ref.LexName)
		fmt.Fprintf(gen.Out, "        return json.Marshal(t.%s)\n", ref.FieldName)
		fmt.Fprintf(gen.Out, "    }\n")
	}
	fmt.Fprintf(gen.Out, "    return nil, fmt.Errorf(\"can not marshal empty union as JSON\")")
	fmt.Fprintf(gen.Out, "}\n\n")

	// ... then UnmarshalJSON
	fmt.Fprintf(gen.Out, "func (t *%s) UnmarshalJSON(b []byte) error {\n", name)
	fmt.Fprintf(gen.Out, "    typ, err := lexutil.TypeExtract(b)\n")
	fmt.Fprintf(gen.Out, "    if err != nil {\n")
	fmt.Fprintf(gen.Out, "        return err\n")
	fmt.Fprintf(gen.Out, "    }\n\n")
	fmt.Fprintf(gen.Out, "    switch typ {\n")
	for _, rname := range refNames {
		ref := unionRefs[rname]
		fmt.Fprintf(gen.Out, "    case \"%s\":\n", ref.LexName)
		fmt.Fprintf(gen.Out, "        t.%s = new(%s)\n", ref.FieldName, ref.TypeName)
		fmt.Fprintf(gen.Out, "        return json.Unmarshal(b, t.%s)\n", ref.FieldName)
	}
	fmt.Fprintf(gen.Out, "    default:\n")
	if union.Closed != nil && *union.Closed {
		// TODO: better error message
		fmt.Fprintf(gen.Out, "        return fmt.Errorf(\"closed unions must match a listed schema\")\n")
	} else {
		fmt.Fprintf(gen.Out, "        return nil\n")
	}
	fmt.Fprintf(gen.Out, "    }\n")
	fmt.Fprintf(gen.Out, "}\n\n")

	// only import CBOR marshalling of unions in legacy mode
	if !gen.Config.LegacyMode {
		return nil
	}

	switch gen.Lex.MainType() {
	case "record", "subscription":
		// no-op
	case "object":
		// hacks for legacy serialization
		nsid := gen.Lex.NSID.String()
		if !(nsid == "app.bsky.richtext.facet" || (nsid == "app.bsky.embed.recordWithMedia" && ft.DefName == "main")) {
			return nil
		}
	default:
		return nil
	}

	// ... then MarshalCBOR
	fmt.Fprintf(gen.Out, "func (t *%s) MarshalCBOR(w io.Writer) error {\n\n", name)
	fmt.Fprintf(gen.Out, "    if t == nil {\n")
	fmt.Fprintf(gen.Out, "        _, err := w.Write(cbg.CborNull)\n")
	fmt.Fprintf(gen.Out, "        return err")
	fmt.Fprintf(gen.Out, "    }\n")
	for _, rname := range refNames {
		ref := unionRefs[rname]
		fmt.Fprintf(gen.Out, "    if t.%s != nil {\n", ref.FieldName)
		fmt.Fprintf(gen.Out, "        return t.%s.MarshalCBOR(w)\n", ref.FieldName)
		fmt.Fprintf(gen.Out, "    }\n")
	}
	fmt.Fprintf(gen.Out, "    return fmt.Errorf(\"can not marshal empty union as CBOR\")")
	fmt.Fprintf(gen.Out, "}\n\n")

	// ... then UnmarshalCBOR
	fmt.Fprintf(gen.Out, "func (t *%s) UnmarshalCBOR(r io.Reader) error {\n", name)
	fmt.Fprintf(gen.Out, "    typ, b, err := lexutil.CborTypeExtractReader(r)\n")
	fmt.Fprintf(gen.Out, "    if err != nil {\n")
	fmt.Fprintf(gen.Out, "        return err\n")
	fmt.Fprintf(gen.Out, "    }\n\n")
	fmt.Fprintf(gen.Out, "    switch typ {\n")
	for _, rname := range refNames {
		ref := unionRefs[rname]
		fmt.Fprintf(gen.Out, "    case \"%s\":\n", ref.LexName)
		fmt.Fprintf(gen.Out, "        t.%s = new(%s)\n", ref.FieldName, ref.TypeName)
		fmt.Fprintf(gen.Out, "        return t.%s.UnmarshalCBOR(bytes.NewReader(b))\n", ref.FieldName)
	}
	fmt.Fprintf(gen.Out, "    default:\n")
	fmt.Fprintf(gen.Out, "        return nil\n")
	fmt.Fprintf(gen.Out, "    }\n")
	fmt.Fprintf(gen.Out, "}\n\n")

	return nil
}

func (gen *FlatGenerator) writeEndpoint(ft *FlatType, desc string, params *lexicon.SchemaParams, output, input *lexicon.SchemaBody, isProcedure bool) error {
	name := gen.baseName()

	fmt.Fprintf(gen.Out, "// %s calls the XRPC method \"%s\".\n", name, gen.Lex.NSID)
	if desc != "" && !gen.Config.LegacyMode {
		fmt.Fprintln(gen.Out, "//")
		for _, l := range strings.Split(desc, "\n") {
			fmt.Fprintf(gen.Out, "// %s\n", l)
		}
	}

	outputBytes := false
	outputStruct := ""
	if output != nil && output.Schema != nil {
		switch v := output.Schema.Inner.(type) {
		case lexicon.SchemaObject, lexicon.SchemaUnion:
			outputStruct = name + "_Output"
		case lexicon.SchemaRef:
			if strings.HasPrefix(v.Ref, "#") {
				// local reference
				outputStruct = fmt.Sprintf("%s_%s", gen.baseName(), strings.Title(v.Ref[1:]))
			} else {
				// external reference
				t, err := gen.externalRefType(v.Ref)
				if err != nil {
					return err
				}
				outputStruct = t
			}
		default:
			return fmt.Errorf("unsupported endpoint output schema def type: %T", output.Schema.Inner)
		}
	} else if output != nil && output.Encoding != "" {
		outputBytes = true
	}

	paramNames := []string{}
	if params != nil {
		for name := range params.Properties {
			paramNames = append(paramNames, name)
		}
	}
	sort.Strings(paramNames)

	args := []string{"ctx context.Context", "c lexutil.LexClient"}
	reqParams := []string{}
	optParams := []string{}
	if len(paramNames) > 0 {
		fmt.Fprintln(gen.Out, "//")
		for _, name := range paramNames {
			param := params.Properties[name]
			ptr := "*"
			if isRequired(params.Required, name) {
				ptr = ""
				reqParams = append(reqParams, name)
			} else {
				optParams = append(optParams, name)
			}
			switch v := param.Inner.(type) {
			case lexicon.SchemaBoolean:
				if v.Description != nil && *v.Description != "" {
					fmt.Fprintf(gen.Out, "// %s: %s\n", name, *v.Description)
				}
				if gen.Config.LegacyMode {
					ptr = ""
				}
				args = append(args, fmt.Sprintf("%s %sbool", name, ptr))
			case lexicon.SchemaInteger:
				if v.Description != nil && *v.Description != "" {
					fmt.Fprintf(gen.Out, "// %s: %s\n", name, *v.Description)
				}
				if gen.Config.LegacyMode {
					ptr = ""
				}
				args = append(args, fmt.Sprintf("%s %sint64", name, ptr))
			case lexicon.SchemaString:
				if v.Description != nil && *v.Description != "" {
					fmt.Fprintf(gen.Out, "// %s: %s\n", name, *v.Description)
				}
				args = append(args, fmt.Sprintf("%s string", name))
			case lexicon.SchemaUnknown:
				if v.Description != nil && *v.Description != "" {
					fmt.Fprintf(gen.Out, "// %s: %s\n", name, *v.Description)
				}
				args = append(args, fmt.Sprintf("%s any", name))
			case lexicon.SchemaArray:
				if v.Description != nil && *v.Description != "" {
					suffix := "[]"
					if gen.Config.LegacyMode {
						suffix = ""
					}
					fmt.Fprintf(gen.Out, "// %s%s: %s\n", name, suffix, *v.Description)
				}
				switch v.Items.Inner.(type) {
				case lexicon.SchemaBoolean:
					args = append(args, fmt.Sprintf("%s []bool", name))
				case lexicon.SchemaInteger:
					args = append(args, fmt.Sprintf("%s []int64", name))
				case lexicon.SchemaString:
					args = append(args, fmt.Sprintf("%s []string", name))
				default:
					return fmt.Errorf("unsupported parameter array type: %T", param.Inner)
				}
			default:
				return fmt.Errorf("unsupported parameter type: %T", param.Inner)
			}
		}
	}

	inputArg := "nil"
	inputEncoding := ""
	inputStruct := ""
	if isProcedure && input != nil && input.Schema != nil {
		inputArg = "input"
		inputEncoding = input.Encoding
		switch v := input.Schema.Inner.(type) {
		case lexicon.SchemaObject, lexicon.SchemaUnion:
			inputStruct = name + "_Input"
		case lexicon.SchemaRef:
			if strings.HasPrefix(v.Ref, "#") {
				// local reference
				inputStruct = fmt.Sprintf("%s_%s", gen.baseName(), strings.Title(v.Ref[1:]))
			} else {
				// external reference
				t, err := gen.externalRefType(v.Ref)
				if err != nil {
					return err
				}
				inputStruct = t
			}
		}
		args = append(args, fmt.Sprintf("input *%s", inputStruct))
	} else if isProcedure && input != nil && input.Encoding != "" {
		inputArg = "input"
		inputEncoding = input.Encoding
		args = append(args, "input io.Reader")
	}

	doOutParam := ""
	returnType := ""
	fmt.Fprintf(gen.Out, "func %s(%s) ", name, strings.Join(args, ", "))
	if outputStruct != "" {
		fmt.Fprintf(gen.Out, "(*%s, error) {\n", outputStruct)
		fmt.Fprintf(gen.Out, "    var out %s\n", outputStruct)
		if !gen.Config.LegacyMode {
			fmt.Fprintln(gen.Out, "")
		}
		doOutParam = "&out"
		returnType = "&out"
	} else if outputBytes {
		fmt.Fprintf(gen.Out, "([]byte, error) {\n")
		fmt.Fprintf(gen.Out, "    buf := new(bytes.Buffer)\n\n")
		doOutParam = "buf"
		returnType = "buf.Bytes()"
	} else {
		fmt.Fprintf(gen.Out, "error {\n")
		doOutParam = "nil"
	}
	paramsArg := "nil"
	if params != nil && len(params.Properties) > 0 {
		paramsArg = "params"
		if gen.Config.LegacyMode {
			fmt.Fprintln(gen.Out, "")
		}
		// TODO: switch to map[string]any
		fmt.Fprintf(gen.Out, "    params := map[string]interface{}{}\n")
	}
	for _, name := range optParams {
		param := params.Properties[name]
		switch param.Inner.(type) {
		case lexicon.SchemaString:
			fmt.Fprintf(gen.Out, "    if %s != \"\" {\n", name)
			fmt.Fprintf(gen.Out, "        params[\"%s\"] = %s\n", name, name)
			fmt.Fprintf(gen.Out, "    }\n")
		case lexicon.SchemaArray:
			fmt.Fprintf(gen.Out, "    if len(%s) != 0 {\n", name)
			fmt.Fprintf(gen.Out, "        params[\"%s\"] = %s\n", name, name)
			fmt.Fprintf(gen.Out, "    }\n")
		case lexicon.SchemaUnknown:
			fmt.Fprintf(gen.Out, "    if %s != nil {\n", name)
			fmt.Fprintf(gen.Out, "        params[\"%s\"] = %s\n", name, name)
			fmt.Fprintf(gen.Out, "    }\n")
		case lexicon.SchemaInteger:
			if gen.Config.LegacyMode {
				fmt.Fprintf(gen.Out, "    if %s != 0 {\n", name)
				fmt.Fprintf(gen.Out, "        params[\"%s\"] = %s\n", name, name)
				fmt.Fprintf(gen.Out, "    }\n")
			} else {
				fmt.Fprintf(gen.Out, "    if %s != nil {\n", name)
				fmt.Fprintf(gen.Out, "        params[\"%s\"] = *%s\n", name, name)
				fmt.Fprintf(gen.Out, "    }\n")
			}
		case lexicon.SchemaBoolean:
			if gen.Config.LegacyMode {
				fmt.Fprintf(gen.Out, "    if %s {\n", name)
				fmt.Fprintf(gen.Out, "        params[\"%s\"] = %s\n", name, name)
				fmt.Fprintf(gen.Out, "    }\n")
			} else {
				fmt.Fprintf(gen.Out, "    if %s != nil {\n", name)
				fmt.Fprintf(gen.Out, "        params[\"%s\"] = *%s\n", name, name)
				fmt.Fprintf(gen.Out, "    }\n")
			}
		default:
			fmt.Fprintf(gen.Out, "    if %s != nil {\n", name)
			fmt.Fprintf(gen.Out, "        params[\"%s\"] = *%s\n", name, name)
			fmt.Fprintf(gen.Out, "    }\n")
		}
	}
	for _, name := range reqParams {
		fmt.Fprintf(gen.Out, "    params[\"%s\"] = %s\n", name, name)
	}
	if !gen.Config.LegacyMode {
		fmt.Fprintln(gen.Out, "")
	}

	method := "lexutil.Query"
	if isProcedure {
		method = "lexutil.Procedure"
	}

	fmt.Fprintf(gen.Out, "    if err := c.LexDo(ctx, %s, \"%s\", \"%s\", %s, %s, %s); err != nil {\n", method, inputEncoding, gen.Lex.NSID, paramsArg, inputArg, doOutParam)
	if returnType != "" {
		fmt.Fprintf(gen.Out, "        return nil, err\n")
	} else {
		fmt.Fprintf(gen.Out, "        return err\n")
	}
	fmt.Fprintf(gen.Out, "    }\n")
	if gen.Config.LegacyMode {
		fmt.Fprintln(gen.Out, "")
	}
	if returnType != "" {
		fmt.Fprintf(gen.Out, "    return %s, nil\n", returnType)
	} else {
		fmt.Fprintf(gen.Out, "    return nil\n")
	}
	fmt.Fprintf(gen.Out, "}\n\n")

	return nil
}
