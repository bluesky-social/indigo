// Code generated by cmd/lexgen (see Makefile's lexgen); DO NOT EDIT.

// Lexicon schema: com.atproto.temp.checkHandleAvailability

package atproto

import (
	"context"
	"encoding/json"
	"fmt"

	lexutil "github.com/bluesky-social/indigo/lex/util"
)

// TempCheckHandleAvailability_Output is the output of a com.atproto.temp.checkHandleAvailability call.
type TempCheckHandleAvailability_Output struct {
	// handle: Echo of the input handle.
	Handle string                                     `json:"handle" cborgen:"handle"`
	Result *TempCheckHandleAvailability_Output_Result `json:"result" cborgen:"result"`
}

type TempCheckHandleAvailability_Output_Result struct {
	TempCheckHandleAvailability_ResultAvailable   *TempCheckHandleAvailability_ResultAvailable
	TempCheckHandleAvailability_ResultUnavailable *TempCheckHandleAvailability_ResultUnavailable
}

func (t *TempCheckHandleAvailability_Output_Result) MarshalJSON() ([]byte, error) {
	if t.TempCheckHandleAvailability_ResultAvailable != nil {
		t.TempCheckHandleAvailability_ResultAvailable.LexiconTypeID = "com.atproto.temp.checkHandleAvailability#resultAvailable"
		return json.Marshal(t.TempCheckHandleAvailability_ResultAvailable)
	}
	if t.TempCheckHandleAvailability_ResultUnavailable != nil {
		t.TempCheckHandleAvailability_ResultUnavailable.LexiconTypeID = "com.atproto.temp.checkHandleAvailability#resultUnavailable"
		return json.Marshal(t.TempCheckHandleAvailability_ResultUnavailable)
	}
	return nil, fmt.Errorf("can not marshal empty union as JSON")
}

func (t *TempCheckHandleAvailability_Output_Result) UnmarshalJSON(b []byte) error {
	typ, err := lexutil.TypeExtract(b)
	if err != nil {
		return err
	}

	switch typ {
	case "com.atproto.temp.checkHandleAvailability#resultAvailable":
		t.TempCheckHandleAvailability_ResultAvailable = new(TempCheckHandleAvailability_ResultAvailable)
		return json.Unmarshal(b, t.TempCheckHandleAvailability_ResultAvailable)
	case "com.atproto.temp.checkHandleAvailability#resultUnavailable":
		t.TempCheckHandleAvailability_ResultUnavailable = new(TempCheckHandleAvailability_ResultUnavailable)
		return json.Unmarshal(b, t.TempCheckHandleAvailability_ResultUnavailable)
	default:
		return nil
	}
}

// TempCheckHandleAvailability_ResultAvailable is a "resultAvailable" in the com.atproto.temp.checkHandleAvailability schema.
//
// Indicates the provided handle is available.
type TempCheckHandleAvailability_ResultAvailable struct {
	LexiconTypeID string `json:"$type" cborgen:"$type,const=com.atproto.temp.checkHandleAvailability#resultAvailable"`
}

// TempCheckHandleAvailability_ResultUnavailable is a "resultUnavailable" in the com.atproto.temp.checkHandleAvailability schema.
//
// Indicates the provided handle is unavailable and gives suggestions of available handles.
type TempCheckHandleAvailability_ResultUnavailable struct {
	LexiconTypeID string `json:"$type" cborgen:"$type,const=com.atproto.temp.checkHandleAvailability#resultUnavailable"`
	// suggestions: List of suggested handles based on the provided inputs.
	Suggestions []*TempCheckHandleAvailability_Suggestion `json:"suggestions" cborgen:"suggestions"`
}

// TempCheckHandleAvailability_Suggestion is a "suggestion" in the com.atproto.temp.checkHandleAvailability schema.
type TempCheckHandleAvailability_Suggestion struct {
	Handle string `json:"handle" cborgen:"handle"`
	// method: Method used to build this suggestion. Should be considered opaque to clients. Can be used for metrics.
	Method string `json:"method" cborgen:"method"`
}

// TempCheckHandleAvailability calls the XRPC method "com.atproto.temp.checkHandleAvailability".
//
// birthDate: User-provided birth date. Might be used to build handle suggestions.
// email: User-provided email. Might be used to build handle suggestions.
// handle: Tentative handle. Will be checked for availability or used to build handle suggestions.
func TempCheckHandleAvailability(ctx context.Context, c lexutil.LexClient, birthDate string, email string, handle string) (*TempCheckHandleAvailability_Output, error) {
	var out TempCheckHandleAvailability_Output

	params := map[string]interface{}{}
	if birthDate != "" {
		params["birthDate"] = birthDate
	}
	if email != "" {
		params["email"] = email
	}
	params["handle"] = handle
	if err := c.LexDo(ctx, lexutil.Query, "", "com.atproto.temp.checkHandleAvailability", params, nil, &out); err != nil {
		return nil, err
	}

	return &out, nil
}
