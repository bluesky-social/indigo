// Code generated by cmd/lexgen (see Makefile's lexgen); DO NOT EDIT.

// Lexicon schema: com.atproto.sync.listHosts

package atproto

import (
	"context"

	lexutil "github.com/bluesky-social/indigo/lex/util"
)

// SyncListHosts_Host is a "host" in the com.atproto.sync.listHosts schema.
type SyncListHosts_Host struct {
	AccountCount *int64 `json:"accountCount,omitempty" cborgen:"accountCount,omitempty"`
	// hostname: hostname of server; not a URL (no scheme)
	Hostname string `json:"hostname" cborgen:"hostname"`
	// seq: Recent repo stream event sequence number. May be delayed from actual stream processing (eg, persisted cursor not in-memory cursor).
	Seq    *int64  `json:"seq,omitempty" cborgen:"seq,omitempty"`
	Status *string `json:"status,omitempty" cborgen:"status,omitempty"`
}

// SyncListHosts_Output is the output of a com.atproto.sync.listHosts call.
type SyncListHosts_Output struct {
	Cursor *string `json:"cursor,omitempty" cborgen:"cursor,omitempty"`
	// hosts: Sort order is not formally specified. Recommended order is by time host was first seen by the server, with oldest first.
	Hosts []*SyncListHosts_Host `json:"hosts" cborgen:"hosts"`
}

// SyncListHosts calls the XRPC method "com.atproto.sync.listHosts".
func SyncListHosts(ctx context.Context, c lexutil.LexClient, cursor string, limit int64) (*SyncListHosts_Output, error) {
	var out SyncListHosts_Output

	params := map[string]interface{}{}
	if cursor != "" {
		params["cursor"] = cursor
	}
	if limit != 0 {
		params["limit"] = limit
	}
	if err := c.LexDo(ctx, lexutil.Query, "", "com.atproto.sync.listHosts", params, nil, &out); err != nil {
		return nil, err
	}

	return &out, nil
}
