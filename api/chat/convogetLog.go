// Code generated by cmd/lexgen (see Makefile's lexgen); DO NOT EDIT.

package chat

// schema: chat.bsky.convo.getLog

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/bluesky-social/indigo/lex/util"
	"github.com/bluesky-social/indigo/xrpc"
)

// ConvoGetLog_Output is the output of a chat.bsky.convo.getLog call.
type ConvoGetLog_Output struct {
	Cursor *string                         `json:"cursor,omitempty" cborgen:"cursor,omitempty"`
	Logs   []*ConvoGetLog_Output_Logs_Elem `json:"logs" cborgen:"logs"`
}

type ConvoGetLog_Output_Logs_Elem struct {
	ConvoDefs_LogBeginConvo     *ConvoDefs_LogBeginConvo
	ConvoDefs_LogAcceptConvo    *ConvoDefs_LogAcceptConvo
	ConvoDefs_LogLeaveConvo     *ConvoDefs_LogLeaveConvo
	ConvoDefs_LogMuteConvo      *ConvoDefs_LogMuteConvo
	ConvoDefs_LogUnmuteConvo    *ConvoDefs_LogUnmuteConvo
	ConvoDefs_LogCreateMessage  *ConvoDefs_LogCreateMessage
	ConvoDefs_LogDeleteMessage  *ConvoDefs_LogDeleteMessage
	ConvoDefs_LogReadMessage    *ConvoDefs_LogReadMessage
	ConvoDefs_LogAddReaction    *ConvoDefs_LogAddReaction
	ConvoDefs_LogRemoveReaction *ConvoDefs_LogRemoveReaction
}

func (t *ConvoGetLog_Output_Logs_Elem) MarshalJSON() ([]byte, error) {
	if t.ConvoDefs_LogBeginConvo != nil {
		t.ConvoDefs_LogBeginConvo.LexiconTypeID = "chat.bsky.convo.defs#logBeginConvo"
		return json.Marshal(t.ConvoDefs_LogBeginConvo)
	}
	if t.ConvoDefs_LogAcceptConvo != nil {
		t.ConvoDefs_LogAcceptConvo.LexiconTypeID = "chat.bsky.convo.defs#logAcceptConvo"
		return json.Marshal(t.ConvoDefs_LogAcceptConvo)
	}
	if t.ConvoDefs_LogLeaveConvo != nil {
		t.ConvoDefs_LogLeaveConvo.LexiconTypeID = "chat.bsky.convo.defs#logLeaveConvo"
		return json.Marshal(t.ConvoDefs_LogLeaveConvo)
	}
	if t.ConvoDefs_LogMuteConvo != nil {
		t.ConvoDefs_LogMuteConvo.LexiconTypeID = "chat.bsky.convo.defs#logMuteConvo"
		return json.Marshal(t.ConvoDefs_LogMuteConvo)
	}
	if t.ConvoDefs_LogUnmuteConvo != nil {
		t.ConvoDefs_LogUnmuteConvo.LexiconTypeID = "chat.bsky.convo.defs#logUnmuteConvo"
		return json.Marshal(t.ConvoDefs_LogUnmuteConvo)
	}
	if t.ConvoDefs_LogCreateMessage != nil {
		t.ConvoDefs_LogCreateMessage.LexiconTypeID = "chat.bsky.convo.defs#logCreateMessage"
		return json.Marshal(t.ConvoDefs_LogCreateMessage)
	}
	if t.ConvoDefs_LogDeleteMessage != nil {
		t.ConvoDefs_LogDeleteMessage.LexiconTypeID = "chat.bsky.convo.defs#logDeleteMessage"
		return json.Marshal(t.ConvoDefs_LogDeleteMessage)
	}
	if t.ConvoDefs_LogReadMessage != nil {
		t.ConvoDefs_LogReadMessage.LexiconTypeID = "chat.bsky.convo.defs#logReadMessage"
		return json.Marshal(t.ConvoDefs_LogReadMessage)
	}
	if t.ConvoDefs_LogAddReaction != nil {
		t.ConvoDefs_LogAddReaction.LexiconTypeID = "chat.bsky.convo.defs#logAddReaction"
		return json.Marshal(t.ConvoDefs_LogAddReaction)
	}
	if t.ConvoDefs_LogRemoveReaction != nil {
		t.ConvoDefs_LogRemoveReaction.LexiconTypeID = "chat.bsky.convo.defs#logRemoveReaction"
		return json.Marshal(t.ConvoDefs_LogRemoveReaction)
	}
	return nil, fmt.Errorf("cannot marshal empty enum")
}
func (t *ConvoGetLog_Output_Logs_Elem) UnmarshalJSON(b []byte) error {
	typ, err := util.TypeExtract(b)
	if err != nil {
		return err
	}

	switch typ {
	case "chat.bsky.convo.defs#logBeginConvo":
		t.ConvoDefs_LogBeginConvo = new(ConvoDefs_LogBeginConvo)
		return json.Unmarshal(b, t.ConvoDefs_LogBeginConvo)
	case "chat.bsky.convo.defs#logAcceptConvo":
		t.ConvoDefs_LogAcceptConvo = new(ConvoDefs_LogAcceptConvo)
		return json.Unmarshal(b, t.ConvoDefs_LogAcceptConvo)
	case "chat.bsky.convo.defs#logLeaveConvo":
		t.ConvoDefs_LogLeaveConvo = new(ConvoDefs_LogLeaveConvo)
		return json.Unmarshal(b, t.ConvoDefs_LogLeaveConvo)
	case "chat.bsky.convo.defs#logMuteConvo":
		t.ConvoDefs_LogMuteConvo = new(ConvoDefs_LogMuteConvo)
		return json.Unmarshal(b, t.ConvoDefs_LogMuteConvo)
	case "chat.bsky.convo.defs#logUnmuteConvo":
		t.ConvoDefs_LogUnmuteConvo = new(ConvoDefs_LogUnmuteConvo)
		return json.Unmarshal(b, t.ConvoDefs_LogUnmuteConvo)
	case "chat.bsky.convo.defs#logCreateMessage":
		t.ConvoDefs_LogCreateMessage = new(ConvoDefs_LogCreateMessage)
		return json.Unmarshal(b, t.ConvoDefs_LogCreateMessage)
	case "chat.bsky.convo.defs#logDeleteMessage":
		t.ConvoDefs_LogDeleteMessage = new(ConvoDefs_LogDeleteMessage)
		return json.Unmarshal(b, t.ConvoDefs_LogDeleteMessage)
	case "chat.bsky.convo.defs#logReadMessage":
		t.ConvoDefs_LogReadMessage = new(ConvoDefs_LogReadMessage)
		return json.Unmarshal(b, t.ConvoDefs_LogReadMessage)
	case "chat.bsky.convo.defs#logAddReaction":
		t.ConvoDefs_LogAddReaction = new(ConvoDefs_LogAddReaction)
		return json.Unmarshal(b, t.ConvoDefs_LogAddReaction)
	case "chat.bsky.convo.defs#logRemoveReaction":
		t.ConvoDefs_LogRemoveReaction = new(ConvoDefs_LogRemoveReaction)
		return json.Unmarshal(b, t.ConvoDefs_LogRemoveReaction)

	default:
		return nil
	}
}

// ConvoGetLog calls the XRPC method "chat.bsky.convo.getLog".
func ConvoGetLog(ctx context.Context, c *xrpc.Client, cursor string) (*ConvoGetLog_Output, error) {
	var out ConvoGetLog_Output

	params := map[string]interface{}{
		"cursor": cursor,
	}
	if err := c.Do(ctx, xrpc.Query, "", "chat.bsky.convo.getLog", params, nil, &out); err != nil {
		return nil, err
	}

	return &out, nil
}
